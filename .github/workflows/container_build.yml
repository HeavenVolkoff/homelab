# yaml-language-server: $schema=https://json.schemastore.org/github-workflow.json

name: Build and Push Container Images

# cSpell:ignore ZSTD_CLEVEL ZSTD_NBTHREADS apparmor_restrict_unprivileged_userns
# cSpell:dictionaries docker shellscript

on:
  workflow_dispatch:
  push:
    branches:
      - "main"
  pull_request:

env:
  ZSTD_CLEVEL: 9
  ZSTD_NBTHREADS: 0
  IMAGE_REGISTRY: ghcr.io/${{ github.repository_owner }}

# Cancel previous runs of the same workflow on the same branch.
concurrency:
  group: ${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: true

jobs:
  filter:
    name: Filter unnecessary runs
    runs-on: ubuntu-latest
    permissions: {}
    outputs:
      github: ${{ steps.changes.outputs.github }}
      continue: ${{ steps.continue.outputs.continue }}
      container: ${{ steps.changes.outputs.container }}
    steps:
      - name: Checkout repository
        uses: &checkout actions/checkout@v5
      - id: changes
        uses: dorny/paths-filter@v3
        with:
          filters: |
            github:
              - '.github/workflows/container_build.yml'
              - '.github/workflows/parse_containerfile_label.sh'
            container:
              - 'containers/**'
      - id: continue
        name: Determine if build is needed
        env:
          CHANGED_GITHUB: ${{ steps.changes.outputs.github }}
          WORKFLOW_DISPATCH: ${{ github.event_name == 'workflow_dispatch' }}
          CHANGED_CONTAINER: ${{ steps.changes.outputs.container }}
        run: |
          set -euo pipefail

          if [ WORKFLOW_DISPATCH == 'true' ] \
            || [ "$CHANGED_GITHUB" == 'true' ] \
            || [ "$CHANGED_CONTAINER" == 'true' ]; then
            echo "Changes detected, proceed with build"
            echo "continue=true" >> $GITHUB_OUTPUT
          else
            echo "No relevant changes detected, skip build"
            echo "continue=false" >> $GITHUB_OUTPUT
          fi

  prepare:
    if: needs.filter.outputs.continue == 'true'
    needs: [filter]
    runs-on: ubuntu-latest
    permissions:
      contents: read
    outputs:
      date: ${{ steps.date.outputs.date }}
      containers: ${{ steps.containers.outputs.containers }}
    steps:
      - name: Checkout repository
        uses: *checkout
      - id: date
        name: Get current date
        run: echo "date=$(date +'%Y%m%d')" >> $GITHUB_OUTPUT
      - id: containers
        name: List containers to build
        run: |
          set -euo pipefail

          echo "containers=[$(
            find containers -maxdepth 2 -type f -name Containerfile -exec dirname {} \; |
            sort | head -c -1 | xargs basename | xargs printf '"%s"' | tr '\n' ','
          )]" >> $GITHUB_OUTPUT
      - name: Echo outputs
        run: |
          echo "${{ toJSON(steps.date.outputs) }}"
          echo "${{ toJSON(steps.containers.outputs) }}"

  build:
    if: needs.filter.outputs.continue == 'true' && needs.prepare.result == 'success' && !cancelled()
    name: Build ${{ matrix.container }} ${{ matrix.architecture }}
    needs: [filter, prepare]
    runs-on: ${{ matrix.architecture == 'x86_64' && 'ubuntu-24.04' || 'ubuntu-24.04-arm' }}
    permissions:
      contents: read # for actions/checkout
      actions: write # for actions/cache and actions/download-artifact
    strategy:
      fail-fast: false
      matrix:
        container: ${{ fromJson(needs.prepare.outputs.containers) }}
        architecture:
          - x86_64
          - aarch64
    steps:
      - name: Checkout repository
        uses: *checkout
      - id: restore
        name: Restore cached image
        uses: &restore actions/cache/restore@v4
        with:
          key: &cache_key ${{ matrix.container }}-${{ matrix.architecture }}-${{ needs.prepare.outputs.date }}-${{ hashFiles(format('containers/{0}/*', matrix.container)) }}
          path: &cache_path ${{ matrix.container }}-${{ matrix.architecture }}.tar
          lookup-only: true
      - &labels_step
        id: labels
        name: Extract labels from Containerfile
        env:
          CONTAINERFILE: containers/${{ matrix.container }}/Containerfile
        run: |
          set -euo pipefail

          {
            echo 'labels<<EOF'
            .github/workflows/parse_containerfile_label.sh "$CONTAINERFILE"
            echo 'EOF'
          } >> $GITHUB_OUTPUT
      - &meta_step
        id: meta
        if: "!steps.restore.outputs.cache-hit"
        name: Gather image metadata
        uses: docker/metadata-action@v5
        with:
          images: ${{ matrix.container }}
          labels: ${{ steps.labels.outputs.labels }}
      - id: build_image
        if: "!steps.restore.outputs.cache-hit"
        name: Build image
        uses: redhat-actions/buildah-build@v2
        with:
          containerfiles: |
            containers/${{ matrix.container }}/Containerfile
          context: containers/${{ matrix.container }}
          image: ${{ matrix.container }}
          tags: ${{ matrix.architecture }}
          labels: ${{ steps.meta.outputs.labels }}
          oci: false
      - name: Export image
        if: "!steps.restore.outputs.cache-hit"
        env:
          IMAGE_TAG: ${{ matrix.architecture }}
          IMAGE_NAME: ${{ matrix.container }}
          IMAGE_PATH: *cache_path
        run: |
          set -euo pipefail
          echo "Exporting image to tarball"
          buildah push "${IMAGE_NAME:?}:${IMAGE_TAG:?}" "docker-archive:${IMAGE_PATH:?}"
      - name: Cache image artifact
        if: "!steps.restore.outputs.cache-hit"
        uses: actions/cache/save@v4
        with:
          key: *cache_key
          path: *cache_path

  push:
    if: needs.filter.outputs.continue == 'true' && needs.build.result == 'success' && !cancelled()
    name: Push multi-arch ${{ matrix.container }}
    runs-on: ubuntu-latest
    needs: [filter, build, prepare]
    permissions:
      contents: read # for actions/checkout
      packages: write # for pushing to ghcr.io
      actions: read # for actions/cache and actions/download-artifact
    strategy:
      fail-fast: false
      matrix:
        container: ${{ fromJson(needs.prepare.outputs.containers) }}
    steps:
      - name: Checkout repository
        uses: *checkout
      - name: Restore image artifact x86_64
        uses: *restore
        with:
          path: ${{ matrix.container }}-x86_64.tar
          key: ${{ matrix.container }}-x86_64-${{ needs.prepare.outputs.date }}-${{ hashFiles(format('containers/{0}/*', matrix.container)) }}
          fail-on-cache-miss: true
      - name: Restore image artifact aarch64
        uses: *restore
        with:
          path: ${{ matrix.container }}-aarch64.tar
          key: ${{ matrix.container }}-aarch64-${{ needs.prepare.outputs.date }}-${{ hashFiles(format('containers/{0}/*', matrix.container)) }}
          fail-on-cache-miss: true
      - *labels_step
      - *meta_step
      - name: Update Buildah
        run: |
          set -euo pipefail

          case "$(uname -m)" in
            x86_64) IMAGE_ARCH='amd64' ;;
            aarch64) IMAGE_ARCH='arm64' ;;
            *) printf "Invalid architecture" >&2; exit 1 ;;
          esac

          echo "Installing up to date buildah for $IMAGE_ARCH"
          curl -fsSL https://github.com/HeavenVolkoff/buildah-static/releases/latest/download/buildah-${IMAGE_ARCH:?}.tar.gz \
            | tar -xzf - -C /usr/local/bin/

          # Workaround issues between custom buildah installation and apparmor
          sudo sysctl -w kernel.apparmor_restrict_unprivileged_userns=0
      - id: create_manifest
        name: Create multi-arch manifest
        env:
          IMAGE_TAG: ${{ matrix.architecture }}
          IMAGE_NAME: ${{ matrix.container }}
        run: |
          set -euo pipefail

          IMAGE_TAGS=()
          for IMAGE in ${IMAGE_NAME:?}-*.tar; do
            IMAGE_ARCH="${IMAGE#${IMAGE_NAME:?}-}"
            IMAGE_ARCH="${IMAGE_ARCH%.tar}"
            IMAGE_TAGS+=("${IMAGE_ARCH:?}")

            echo "Importing ${IMAGE:?} for architecture ${IMAGE_ARCH:?}"
            buildah pull --arch="${IMAGE_ARCH:?}" "docker-archive:${IMAGE:?}"
          done

          echo
          echo "Creating manifest for ${IMAGE_NAME:?}"
          buildah manifest create --annotation="$(
            echo '${{ steps.meta.outputs.labels }}' | \
              head -c -1 | sed -e 's/, \{0,1\}/ /g' | tr '\n' ','
          )" "${IMAGE_NAME:?}:latest"

          for IMAGE_TAG in "${IMAGE_TAGS[@]}"; do
            IMAGE="${IMAGE_NAME:?}:${IMAGE_TAG:?}"
            echo "Adding ${IMAGE:?} to manifest"
            buildah manifest add "${IMAGE_NAME:?}:latest" "$IMAGE"
          done

          echo
          echo 'Final manifest contents:'
          buildah manifest inspect "${IMAGE_NAME:?}"
      # Workaround bug where capital letters in your GitHub username make it impossible to push to GHCR.
      # https://github.com/macbre/push-to-ghcr/issues/12
      - id: registry_case
        if: github.event_name != 'pull_request'
        name: Lowercase registry
        uses: ASzc/change-string-case-action@v6
        with:
          string: ${{ env.IMAGE_REGISTRY }}
      - id: push
        if: github.event_name != 'pull_request'
        name: Push image to GHCR
        uses: redhat-actions/push-to-registry@v2
        env:
          REGISTRY_USER: ${{ github.actor }}
          REGISTRY_PASSWORD: ${{ github.token }}
        with:
          image: ${{ matrix.container }}
          tags: latest
          registry: ${{ steps.registry_case.outputs.lowercase }}
          username: ${{ env.REGISTRY_USER }}
          password: ${{ env.REGISTRY_PASSWORD }}

  check:
    if: ${{ always() }}
    name: Container build result
    needs: [push]
    runs-on: ubuntu-latest
    permissions: {}
    steps:
      - name: Check result
        env:
          RESULT: ${{ needs.push.result }}
        run: |
          if [ "$RESULT" == "success" ] || [ "$RESULT" == "skipped" ]; then
            exit 0
          else
            exit 1
          fi
