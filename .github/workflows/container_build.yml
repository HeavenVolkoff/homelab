name: Build and Push Container Images

on:
  workflow_dispatch:
  push:
    paths:
      - "containers/**"
      - ".github/workflows/container_build.yml"
    branches:
      - "main"
  pull_request:
    paths:
      - "containers/**"
      - ".github/workflows/container_build.yml"

env:
  ZSTD_CLEVEL: 9
  ZSTD_NBTHREADS: 0
  IMAGE_REGISTRY: ghcr.io/${{ github.repository_owner }}

# Cancel previous runs of the same workflow on the same branch.
concurrency:
  group: ${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: true

jobs:
  prepare:
    runs-on: ubuntu-latest
    permissions:
      contents: read
    outputs:
      date: ${{ steps.date.outputs.date }}
      containers: ${{ steps.containers.outputs.containers }}
    steps:
      - name: Checkout repository
        uses: &checkout actions/checkout@v5
      - id: date
        name: Get current date
        run: echo "date=$(date +'%Y%m%d')" >> $GITHUB_OUTPUT
      - id: containers
        name: List containers to build
        run: |
          set -euo pipefail

          echo "containers=[$(
            find containers -maxdepth 2 -type f -name Containerfile -exec dirname {} \; |
            sort | head -c -1 | xargs basename | xargs printf '"%s"' | tr '\n' ','
          )]" >> $GITHUB_OUTPUT
      - name: Echo outputs
        run: |
          echo "${{ toJSON(steps.date.outputs) }}"
          echo "${{ toJSON(steps.containers.outputs) }}"

  build:
    name: Build ${{ matrix.container }} ${{ matrix.architecture }}
    if: '!cancelled()'
    needs: [prepare]
    runs-on: ${{ matrix.architecture == 'x86_64' && 'ubuntu-24.04' || 'ubuntu-24.04-arm' }}
    permissions:
      contents: read # for actions/checkout
      actions: write # for actions/cache and actions/download-artifact
    strategy:
      fail-fast: false
      matrix:
        container: ${{ fromJson(needs.prepare.outputs.containers) }}
        architecture:
          - x86_64
          - aarch64
    steps:
      - name: Checkout repository
        uses: *checkout
      - id: restore
        name: Restore cached image
        uses: &restore actions/cache/restore@v4
        with:
          key: &cache_key ${{ matrix.container }}-${{ matrix.architecture }}-${{ needs.prepare.outputs.date }}-${{ hashFiles('ucore/**/*') }}
          path: &cache_path ${{ matrix.container }}-${{ matrix.architecture }}.tar
          lookup-only: true
      - id: labels
        name: Extract labels from Containerfile
        env: &labels_env
          CONTAINERFILE: containers/${{ matrix.container }}/Containerfile
        run: &labels_run |
          set -euo pipefail

          {
            echo 'labels<<EOF'
            .github/workflows/parse_containerfile_label.sh "$CONTAINERFILE"
            echo 'EOF'
          } >> $GITHUB_OUTPUT
      - id: meta
        if: '!steps.restore.outputs.cache-hit'
        name: Gather image metadata
        uses: &metadata_action docker/metadata-action@v5
        with: &metadata
          images: ${{ matrix.container }}
          labels: ${{ steps.labels.outputs.labels }}
      - id: build_image
        if: '!steps.restore.outputs.cache-hit'
        name: Build image
        uses: redhat-actions/buildah-build@v2
        with:
          containerfiles: |
            containers/${{ matrix.container }}/Containerfile
          context: containers/${{ matrix.container }}
          image: ${{ matrix.container }}
          tags: ${{ matrix.architecture }}
          labels: ${{ steps.meta.outputs.labels }}
          oci: false
      - name: Export image
        if: '!steps.restore.outputs.cache-hit'
        env:
          IMAGE_TAG: ${{ matrix.architecture }}
          IMAGE_NAME: ${{ matrix.container }}
          IMAGE_PATH: *cache_path
        run: |
          echo "Exporting image to tarball"
          buildah push "${IMAGE_NAME:?}:${IMAGE_TAG:?}" "docker-archive:${IMAGE_PATH:?}.tar"
      - name: Cache image artifact
        if: '!steps.restore.outputs.cache-hit'
        uses: actions/cache/save@v4
        with:
          key: *cache_key
          path: *cache_path

  push:
    name: Push multi-arch ${{ matrix.container }}
    runs-on: ubuntu-latest
    needs: [build, prepare]
    permissions:
      contents: read # for actions/checkout
      packages: write # for pushing to ghcr.io
      actions: read # for actions/cache and actions/download-artifact
    strategy:
      fail-fast: false
      matrix:
        container: ${{ fromJson(needs.prepare.outputs.containers) }}
    steps:
      - name: Checkout repository
        uses: *checkout
      - name: Restore image artifact x86_64
        uses: *restore
        with:
          path: ${{ matrix.container }}-x86_64.tar
          key: ${{ matrix.container }}-x86_64-${{ needs.prepare.outputs.date }}-${{ hashFiles('ucore/**/*') }}
          fail-on-cache-miss: true
      - name: Restore image artifact aarch64
        uses: *restore
        with:
          path: ${{ matrix.container }}-aarch64.tar
          key: ${{ matrix.container }}-aarch64-${{ needs.prepare.outputs.date }}-${{ hashFiles('ucore/**/*') }}
          fail-on-cache-miss: true
      - id: labels
        name: Extract labels from Containerfile
        env: *labels_env
        run: *labels_run
      - id: meta
        name: Gather image metadata
        uses: *metadata_action
        with: *metadata
      - name: Update Buildah
        run: |
          set -euo pipefail

          case "$(uname -m)" in
            x86_64) IMAGE_ARCH='amd64' ;;
            aarch64) IMAGE_ARCH='arm64' ;;
            *) printf "Invalid architecture" >&2; exit 1 ;;
          esac

          echo "Installing up to date buildah for $IMAGE_ARCH"
          curl -fsSL https://github.com/HeavenVolkoff/buildah-static/releases/latest/download/buildah-${IMAGE_ARCH:?}.tar.gz \
            | tar -xzf - -C /usr/local/bin/

          # Workaround issues between custom buildah installation and apparmor
          sudo sysctl -w kernel.apparmor_restrict_unprivileged_userns=0
      - id: create_manifest
        name: Create multi-arch manifest
        env:
          IMAGE_TAG: ${{ matrix.architecture }}
          IMAGE_NAME: ${{ matrix.container }}
        run: |
          set -euo pipefail

          IMAGE_TAGS=()
          for IMAGE in ucore-*.tar; do
            IMAGE_ARCH="${IMAGE#ucore-}"
            IMAGE_ARCH="${IMAGE_ARCH%.tar}"
            IMAGE_TAGS+=("${IMAGE_ARCH:?}")

            echo "Importing ${IMAGE:?} for architecture ${IMAGE_ARCH:?}"
            buildah pull --arch="${IMAGE_ARCH:?}" "docker-archive:${IMAGE:?}"
          done

          echo
          echo "Creating manifest for ${IMAGE_NAME:?}"
          buildah manifest create --annotation="$(
            echo '${{ steps.meta.outputs.labels }}' | \
              head -c -1 | sed -e 's/, \{0,1\}/ /g' | tr '\n' ','
          )" "${IMAGE_NAME:?}:latest"

          for IMAGE_TAG in "${IMAGE_TAGS[@]}"; do
            IMAGE="${IMAGE_NAME:?}:${IMAGE_TAG:?}"
            echo "Adding ${IMAGE:?} to manifest"
            buildah manifest add "${IMAGE_NAME:?}:latest" "$IMAGE"
          done

          echo
          echo 'Final manifest contents:'
          buildah manifest inspect "${IMAGE_NAME:?}"
      # Workaround bug where capital letters in your GitHub username make it impossible to push to GHCR.
      # https://github.com/macbre/push-to-ghcr/issues/12
      - id: registry_case
        name: Lowercase registry
        uses: ASzc/change-string-case-action@v6
        with:
          string: ${{ env.IMAGE_REGISTRY }}
      - id: push
        if: github.event_name != 'pull_request'
        name: Push image to GHCR
        uses: redhat-actions/push-to-registry@v2
        env:
          REGISTRY_USER: ${{ github.actor }}
          REGISTRY_PASSWORD: ${{ github.token }}
        with:
          image: ${{ matrix.container }}
          tags: latest
          registry: ${{ steps.registry_case.outputs.lowercase }}
          username: ${{ env.REGISTRY_USER }}
          password: ${{ env.REGISTRY_PASSWORD }}

  check:
    name: Check all successful
    runs-on: ubuntu-latest
    needs: [push]
    permissions: {}
    steps:
      - name: Exit
        env:
          RESULT: ${{ needs.push.result }}
        run: |
          if [[ "$RESULT" == "success" || "$RESULT" == "skipped" ]]; then
            exit 0
          else
            exit 1
          fi
